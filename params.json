{
  "name": "Shapelocker",
  "tagline": "PATTERN LOCK, unlock using gestures (手势解锁,九宫格解锁,图形解锁)",
  "body": "# ShapeLocker\r\nPATTERN LOCK, unlock with gestures<br>\r\n(手势解锁,九宫格解锁,图形解锁)<br><br>\r\n![image](https://github.com/panespanes/ShapeLocker/raw/master/mdp1.png)\r\n<br>\r\n<br>\r\n<br>\r\n<br>\r\nUNSOLVED:<br>\r\n尚未解决的问题:\r\n (不影响真机运行的应用, 有在模拟器上运行的需求见下文解决办法)<br>\r\n 有同学反映<strong><em>模拟器上运行</strong></em>会出现\"密码圈绘制不全\"的bug, 如图<br>\r\n \r\n ![image](https://github.com/panespanes/ShapeLocker/blob/master/mdp.png)\r\n <br>\r\n 做了些实验, 真机不会出现这个bug, AVD自带模拟器没有重现, BlueStacks模拟器没有类似情况,<br> 而\"靠谱助手\",\"海马玩\",\"逍遥模拟器\"等VirtualBox底层的模拟器均重现bug.<br>\r\n 猜测是由于VirtualBox的驱动对于安卓UI图形绘制的支持并不全面导致的:<br>\r\n 具体原因ShapeLocker对界面刷新做了优化, 响应触摸事件后<strong><em>只重绘被影响区域</em></strong>,<br> \r\n 相关代码:   \r\n ```java  \r\n\r\n Rect invalidateRect = new Rect();\r\n ...\r\n invalidateRect.set((int) (left - radius), (int) (top - radius), (int) (right + radius), (int) (bottom + radius));\r\n ...\r\n invalidateRect.union((int) (left - radius), (int) (top - radius), (int) (right + radius), (int) (bottom + radius));\r\n ...\r\n invalidateRect.set((int) (left - widthOffset), (int) (top - heightOffset), (int) (right + widthOffset), (int) (bottom + heightOffset));\r\n ...\r\n invalidate(invalidateRect);\r\n\r\n```\r\n 而VirtualBox并不会按照严格按照rect大小重绘区域.<br>\r\n 解决办法(真机运行的项目中请不要这样修改, 因为会造成平均34%左右性能损失):<br>\r\n 将这部分代码改为\r\n ```java\r\ninvalidate();\r\n ```\r\n 即可.\r\n",
  "note": "Don't delete this file! It's used internally to help with page regeneration."
}